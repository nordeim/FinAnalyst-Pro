# finanalyst_tools/calculations/base.py
"""
Base infrastructure for financial calculators.

Provides:
- BaseCalculator abstract class with common functionality
- Helper functions for creating calculation results
- Value extraction utilities
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Any, Callable

from finanalyst_tools.config import (
    PlausibilityRanges,
    METRIC_FORMULAS,
    METRIC_UNITS,
    DECIMAL_PLACES,
)
from finanalyst_tools.models.analysis_results import (
    CalculationResult,
    MetricUnit,
    MetricCategory,
    MetricCollection,
)
from finanalyst_tools.models.financial_statements import (
    IncomeStatementData,
    BalanceSheetData,
    CashFlowStatementData,
    FinancialStatementSet,
    FinancialPeriod,
)
from finanalyst_tools.utils.math_ops import (
    to_decimal,
    safe_divide,
    round_decimal,
    calculate_percentage,
    calculate_average,
)


def extract_value(
    data: dict[str, Any] | Any,
    field_name: str,
    default: Decimal | None = None,
) -> Decimal | None:
    """
    Extract a numeric value from data, handling various input types.
    
    Args:
        data: Source data (dict, Pydantic model, or value)
        field_name: Name of field to extract
        default: Default value if field not found
        
    Returns:
        Decimal value or default
    """
    if data is None:
        return default
    
    # If it's a Pydantic model, try to get attribute
    if hasattr(data, field_name):
        value = getattr(data, field_name)
        if value is not None:
            return to_decimal(value)
    
    # If it's a dict, try to get key
    if isinstance(data, dict):
        value = data.get(field_name)
        if value is not None:
            return to_decimal(value)
    
    return default


def get_metric_unit(metric_name: str) -> MetricUnit:
    """Get the appropriate unit for a metric."""
    unit_str = METRIC_UNITS.get(metric_name.lower(), "ratio")
    
    unit_map = {
        "percentage": MetricUnit.PERCENTAGE,
        "ratio": MetricUnit.RATIO,
        "currency": MetricUnit.CURRENCY,
        "days": MetricUnit.DAYS,
        "count": MetricUnit.COUNT,
        "times": MetricUnit.TIMES,
    }
    
    return unit_map.get(unit_str, MetricUnit.RATIO)


def get_metric_formula(metric_name: str) -> str:
    """Get the formula for a metric."""
    return METRIC_FORMULAS.get(metric_name.lower(), "Custom calculation")


def create_calculation_result(
    metric_name: str,
    value: Decimal | None,
    inputs: dict[str, Any],
    calculation_steps: list[str],
    category: MetricCategory | None = None,
    custom_formula: str | None = None,
    custom_unit: MetricUnit | None = None,
) -> CalculationResult:
    """
    Factory function to create a CalculationResult with plausibility check.
    
    Args:
        metric_name: Name of the metric
        value: Calculated value
        inputs: Dictionary of input values used
        calculation_steps: List of calculation step descriptions
        category: Optional metric category
        custom_formula: Optional custom formula (uses default if not provided)
        custom_unit: Optional custom unit (uses default if not provided)
        
    Returns:
        Complete CalculationResult with plausibility assessment
    """
    # Get formula and unit
    formula = custom_formula or get_metric_formula(metric_name)
    unit = custom_unit or get_metric_unit(metric_name)
    
    # Get plausibility range
    plausibility_range = PlausibilityRanges.get_range(metric_name)
    
    # Check plausibility
    is_plausible = True
    warnings = []
    
    if value is not None and plausibility_range is not None:
        float_value = float(value)
        min_val, max_val = plausibility_range
        
        if float_value < min_val:
            is_plausible = False
            warnings.append(
                f"Value {float_value:.2f} is below typical range "
                f"({min_val:.1f} to {max_val:.1f})"
            )
        elif float_value > max_val:
            is_plausible = False
            warnings.append(
                f"Value {float_value:.2f} is above typical range "
                f"({min_val:.1f} to {max_val:.1f})"
            )
    
    # Convert inputs to serializable format
    serializable_inputs = {}
    for key, val in inputs.items():
        if isinstance(val, Decimal):
            serializable_inputs[key] = float(val)
        elif val is None:
            serializable_inputs[key] = None
        else:
            serializable_inputs[key] = val
    
    return CalculationResult(
        metric_name=metric_name,
        value=value,
        unit=unit,
        formula=formula,
        inputs=serializable_inputs,
        calculation_steps=calculation_steps,
        is_plausible=is_plausible,
        plausibility_range=plausibility_range,
        warnings=warnings,
        category=category,
    )


class BaseCalculator(ABC):
    """
    Abstract base class for financial calculators.
    
    Provides common functionality:
    - Step logging
    - Plausibility checking
    - Result formatting
    - Warning accumulation
    """
    
    def __init__(self, category: MetricCategory):
        """
        Initialize the calculator.
        
        Args:
            category: The category of metrics this calculator produces
        """
        self.category = category
        self._steps: list[str] = []
        self._warnings: list[str] = []
        self._inputs: dict[str, Any] = {}
    
    def _reset(self) -> None:
        """Reset internal state for new calculation."""
        self._steps = []
        self._warnings = []
        self._inputs = {}
    
    def _add_step(self, description: str) -> None:
        """Add a calculation step."""
        step_num = len(self._steps) + 1
        self._steps.append(f"Step {step_num}: {description}")
    
    def _add_warning(self, warning: str) -> None:
        """Add a warning message."""
        self._warnings.append(warning)
    
    def _record_input(self, name: str, value: Any) -> None:
        """Record an input value."""
        if isinstance(value, Decimal):
            self._inputs[name] = float(value)
        else:
            self._inputs[name] = value
    
    def _create_result(
        self,
        metric_name: str,
        value: Decimal | None,
        formula: str | None = None,
        unit: MetricUnit | None = None,
    ) -> CalculationResult:
        """Create a calculation result with current state."""
        result = create_calculation_result(
            metric_name=metric_name,
            value=value,
            inputs=self._inputs.copy(),
            calculation_steps=self._steps.copy(),
            category=self.category,
            custom_formula=formula,
            custom_unit=unit,
        )
        
        # Add any accumulated warnings
        for warning in self._warnings:
            result.add_warning(warning)
        
        return result
    
    @abstractmethod
    def calculate_all(
        self,
        data: FinancialStatementSet | dict[str, Any],
        prior_data: FinancialStatementSet | dict[str, Any] | None = None,
    ) -> MetricCollection:
        """
        Calculate all metrics for this category.
        
        Args:
            data: Current period financial data
            prior_data: Prior period data (for averages)
            
        Returns:
            MetricCollection with all calculated metrics
        """
        pass
