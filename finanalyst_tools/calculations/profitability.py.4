# finanalyst_tools/calculations/profitability.py
"""
Profitability ratio calculators.

Provides calculations for:
- Gross Profit Margin
- Operating Profit Margin
- Net Profit Margin
- EBITDA Margin
- Return on Assets (ROA)
- Return on Equity (ROE)
- Return on Capital Employed (ROCE)
"""

from __future__ import annotations

from decimal import Decimal
from typing import Any

from finanalyst_tools.config import DECIMAL_PLACES, METRIC_FORMULAS
from finanalyst_tools.models.analysis_results import (
    CalculationResult,
    MetricUnit,
    MetricCategory,
    MetricCollection,
)
from finanalyst_tools.models.financial_statements import (
    IncomeStatementData,
    BalanceSheetData,
    FinancialStatementSet,
    FinancialPeriod,
)
from finanalyst_tools.utils.math_ops import (
    to_decimal,
    safe_divide,
    round_decimal,
    calculate_percentage,
    calculate_average,
    is_effectively_zero,
)
from finanalyst_tools.calculations.base import (
    BaseCalculator,
    create_calculation_result,
    extract_value,
)


# ============================================================================
# STANDALONE CALCULATION FUNCTIONS
# ============================================================================

def calculate_gross_profit_margin(
    revenue: Decimal | float | int,
    cost_of_goods_sold: Decimal | float | int,
) -> CalculationResult:
    """
    Calculate Gross Profit Margin.
    
    Formula: (Revenue - COGS) / Revenue × 100
    
    Args:
        revenue: Total revenue / net sales
        cost_of_goods_sold: Cost of goods sold
        
    Returns:
        CalculationResult with margin percentage
    """
    steps = []
    inputs = {}
    
    # Convert inputs
    rev = to_decimal(revenue)
    cogs = to_decimal(cost_of_goods_sold)
    
    inputs["revenue"] = float(rev)
    inputs["cost_of_goods_sold"] = float(cogs)
    
    steps.append(f"Revenue = {rev:,.2f}")
    steps.append(f"COGS = {cogs:,.2f}")
    
    # Calculate gross profit
    gross_profit = rev - cogs
    steps.append(f"Gross Profit = Revenue - COGS = {rev:,.2f} - {cogs:,.2f} = {gross_profit:,.2f}")
    
    # Calculate margin
    if is_effectively_zero(rev):
        steps.append("Revenue is zero, cannot calculate margin")
        value = None
    else:
        margin = (gross_profit / rev) * 100
        value = round_decimal(margin, DECIMAL_PLACES["percentage"])
        steps.append(f"Gross Profit Margin = (Gross Profit / Revenue) × 100 = ({gross_profit:,.2f} / {rev:,.2f}) × 100 = {value:.2f}%")
    
    return create_calculation_result(
        metric_name="Gross Profit Margin",
        value=value,
        inputs=inputs,
        calculation_steps=steps,
        category=MetricCategory.PROFITABILITY,
        custom_formula="(Revenue - COGS) / Revenue × 100",
        custom_unit=MetricUnit.PERCENTAGE,
    )


def calculate_operating_profit_margin(
    revenue: Decimal | float | int,
    cost_of_goods_sold: Decimal | float | int,
    operating_expenses: Decimal | float | int | None = None,
    selling_general_admin: Decimal | float | int | None = None,
    marketing_expenses: Decimal | float | int | None = None,
    research_development: Decimal | float | int | None = None,
    depreciation_amortization: Decimal | float | int | None = None,
    other_operating_expenses: Decimal | float | int | None = None,
) -> CalculationResult:
    """
    Calculate Operating Profit Margin.
    
    Formula: (Revenue - COGS - OpEx) / Revenue × 100
    
    Args:
        revenue: Total revenue
        cost_of_goods_sold: COGS
        operating_expenses: Total OpEx (if aggregated)
        selling_general_admin: SG&A expenses
        marketing_expenses: Marketing expenses
        research_development: R&D expenses
        depreciation_amortization: D&A
        other_operating_expenses: Other OpEx
        
    Returns:
        CalculationResult with margin percentage
    """
    steps = []
    inputs = {}
    
    # Convert inputs
    rev = to_decimal(revenue)
    cogs = to_decimal(cost_of_goods_sold)
    
    inputs["revenue"] = float(rev)
    inputs["cost_of_goods_sold"] = float(cogs)
    
    steps.append(f"Revenue = {rev:,.2f}")
    steps.append(f"COGS = {cogs:,.2f}")
    
    # Calculate total operating expenses
    if operating_expenses is not None:
        opex = to_decimal(operating_expenses)
        inputs["operating_expenses"] = float(opex)
        steps.append(f"Operating Expenses (provided) = {opex:,.2f}")
    else:
        opex = Decimal("0")
        components = [
            ("SG&A", selling_general_admin),
            ("Marketing", marketing_expenses),
            ("R&D", research_development),
            ("D&A", depreciation_amortization),
            ("Other OpEx", other_operating_expenses),
        ]
        
        for name, val in components:
            if val is not None:
                dec_val = to_decimal(val)
                opex += dec_val
                inputs[name.lower().replace("&", "_")] = float(dec_val)
                steps.append(f"{name} = {dec_val:,.2f}")
        
        steps.append(f"Total Operating Expenses = {opex:,.2f}")
    
    # Calculate operating profit
    gross_profit = rev - cogs
    operating_profit = gross_profit - opex
    steps.append(f"Operating Profit = Gross Profit - OpEx = {gross_profit:,.2f} - {opex:,.2f} = {operating_profit:,.2f}")
    
    # Calculate margin
    if is_effectively_zero(rev):
        steps.append("Revenue is zero, cannot calculate margin")
        value = None
    else:
        margin = (operating_profit / rev) * 100
        value = round_decimal(margin, DECIMAL_PLACES["percentage"])
        steps.append(f"Operating Profit Margin = (Operating Profit / Revenue) × 100 = {value:.2f}%")
    
    return create_calculation_result(
        metric_name="Operating Profit Margin",
        value=value,
        inputs=inputs,
        calculation_steps=steps,
        category=MetricCategory.PROFITABILITY,
        custom_formula="(Revenue - COGS - OpEx) / Revenue × 100",
        custom_unit=MetricUnit.PERCENTAGE,
    )


def calculate_net_profit_margin(
    revenue: Decimal | float | int,
    net_income: Decimal | float | int,
) -> CalculationResult:
    """
    Calculate Net Profit Margin.
    
    Formula: Net Income / Revenue × 100
    
    Args:
        revenue: Total revenue
        net_income: Net income / net profit
        
    Returns:
        CalculationResult with margin percentage
    """
    steps = []
    inputs = {}
    
    rev = to_decimal(revenue)
    ni = to_decimal(net_income)
    
    inputs["revenue"] = float(rev)
    inputs["net_income"] = float(ni)
    
    steps.append(f"Revenue = {rev:,.2f}")
    steps.append(f"Net Income = {ni:,.2f}")
    
    if is_effectively_zero(rev):
        steps.append("Revenue is zero, cannot calculate margin")
        value = None
    else:
        margin = (ni / rev) * 100
        value = round_decimal(margin, DECIMAL_PLACES["percentage"])
        steps.append(f"Net Profit Margin = (Net Income / Revenue) × 100 = ({ni:,.2f} / {rev:,.2f}) × 100 = {value:.2f}%")
    
    result = create_calculation_result(
        metric_name="Net Profit Margin",
        value=value,
        inputs=inputs,
        calculation_steps=steps,
        category=MetricCategory.PROFITABILITY,
        custom_formula="Net Income / Revenue × 100",
        custom_unit=MetricUnit.PERCENTAGE,
    )
    
    # Add warning for unusual values
    if value is not None and float(value) >= 100:
        result.add_warning("Net margin >= 100% is unusual - verify data accuracy")
    
    return result


def calculate_ebitda_margin(
    revenue: Decimal | float | int,
    ebitda: Decimal | float | int,
) -> CalculationResult:
    """
    Calculate EBITDA Margin.
    
    Formula: EBITDA / Revenue × 100
    
    Args:
        revenue: Total revenue
        ebitda: Earnings Before Interest, Taxes, Depreciation, and Amortization
        
    Returns:
        CalculationResult with margin percentage
    """
    steps = []
    inputs = {}
    
    rev = to_decimal(revenue)
    ebitda_val = to_decimal(ebitda)
    
    inputs["revenue"] = float(rev)
    inputs["ebitda"] = float(ebitda_val)
    
    steps.append(f"Revenue = {rev:,.2f}")
    steps.append(f"EBITDA = {ebitda_val:,.2f}")
    
    if is_effectively_zero(rev):
        steps.append("Revenue is zero, cannot calculate margin")
        value = None
    else:
        margin = (ebitda_val / rev) * 100
        value = round_decimal(margin, DECIMAL_PLACES["percentage"])
        steps.append(f"EBITDA Margin = (EBITDA / Revenue) × 100 = ({ebitda_val:,.2f} / {rev:,.2f}) × 100 = {value:.2f}%")
    
    return create_calculation_result(
        metric_name="EBITDA Margin",
        value=value,
        inputs=inputs,
        calculation_steps=steps,
        category=MetricCategory.PROFITABILITY,
        custom_formula="EBITDA / Revenue × 100",
        custom_unit=MetricUnit.PERCENTAGE,
    )


def calculate_return_on_assets(
    net_income: Decimal | float | int,
    total_assets_begin: Decimal | float | int,
    total_assets_end: Decimal | float | int | None = None,
) -> CalculationResult:
    """
    Calculate Return on Assets (ROA).
    
    Formula: Net Income / Average Total Assets × 100
    
    Args:
        net_income: Net income for the period
        total_assets_begin: Total assets at beginning of period
        total_assets_end: Total assets at end of period (optional, uses begin if not provided)
        
    Returns:
        CalculationResult with ROA percentage
    """
    steps = []
    inputs = {}
    
    ni = to_decimal(net_income)
    assets_begin = to_decimal(total_assets_begin)
    assets_end = to_decimal(total_assets_end) if total_assets_end is not None else assets_begin
    
    inputs["net_income"] = float(ni)
    inputs["total_assets_begin"] = float(assets_begin)
    inputs["total_assets_end"] = float(assets_end)
    
    steps.append(f"Net Income = {ni:,.2f}")
    steps.append(f"Total Assets (Beginning) = {assets_begin:,.2f}")
    steps.append(f"Total Assets (Ending) = {assets_end:,.2f}")
    
    # Calculate average assets
    avg_assets = (assets_begin + assets_end) / 2
    steps.append(f"Average Total Assets = ({assets_begin:,.2f} + {assets_end:,.2f}) / 2 = {avg_assets:,.2f}")
    
    if is_effectively_zero(avg_assets):
        steps.append("Average assets is zero, cannot calculate ROA")
        value = None
    else:
        roa = (ni / avg_assets) * 100
        value = round_decimal(roa, DECIMAL_PLACES["percentage"])
        steps.append(f"ROA = (Net Income / Average Total Assets) × 100 = ({ni:,.2f} / {avg_assets:,.2f}) × 100 = {value:.2f}%")
    
    return create_calculation_result(
        metric_name="Return on Assets",
        value=value,
        inputs=inputs,
        calculation_steps=steps,
        category=MetricCategory.PROFITABILITY,
        custom_formula="Net Income / Average Total Assets × 100",
        custom_unit=MetricUnit.PERCENTAGE,
    )


def calculate_return_on_equity(
    net_income: Decimal | float | int,
    shareholders_equity_begin: Decimal | float | int,
    shareholders_equity_end: Decimal | float | int | None = None,
) -> CalculationResult:
    """
    Calculate Return on Equity (ROE).
    
    Formula: Net Income / Average Shareholders' Equity × 100
    
    Args:
        net_income: Net income for the period
        shareholders_equity_begin: Equity at beginning of period
        shareholders_equity_end: Equity at end of period (optional)
        
    Returns:
        CalculationResult with ROE percentage
    """
    steps = []
    inputs = {}
    warnings = []
    
    ni = to_decimal(net_income)
    equity_begin = to_decimal(shareholders_equity_begin)
    equity_end = to_decimal(shareholders_equity_end) if shareholders_equity_end is not None else equity_begin
    
    inputs["net_income"] = float(ni)
    inputs["shareholders_equity_begin"] = float(equity_begin)
    inputs["shareholders_equity_end"] = float(equity_end)
    
    steps.append(f"Net Income = {ni:,.2f}")
    steps.append(f"Shareholders' Equity (Beginning) = {equity_begin:,.2f}")
    steps.append(f"Shareholders' Equity (Ending) = {equity_end:,.2f}")
    
    # Check for negative equity
    if equity_begin < 0 or equity_end < 0:
        warnings.append("Negative shareholders' equity detected - ROE interpretation may be misleading")
    
    # Calculate average equity
    avg_equity = (equity_begin + equity_end) / 2
    steps.append(f"Average Shareholders' Equity = ({equity_begin:,.2f} + {equity_end:,.2f}) / 2 = {avg_equity:,.2f}")
    
    if is_effectively_zero(avg_equity):
        steps.append("Average equity is zero, cannot calculate ROE")
        value = None
    else:
        roe = (ni / avg_equity) * 100
        value = round_decimal(roe, DECIMAL_PLACES["percentage"])
        steps.append(f"ROE = (Net Income / Average Equity) × 100 = ({ni:,.2f} / {avg_equity:,.2f}) × 100 = {value:.2f}%")
    
    result = create_calculation_result(
        metric_name="Return on Equity",
        value=value,
        inputs=inputs,
        calculation_steps=steps,
        category=MetricCategory.PROFITABILITY,
        custom_formula="Net Income / Average Shareholders' Equity × 100",
        custom_unit=MetricUnit.PERCENTAGE,
    )
    
    for warning in warnings:
        result.add_warning(warning)
    
    return result


def calculate_return_on_capital_employed(
    ebit: Decimal | float | int,
    total_assets: Decimal | float | int,
    current_liabilities: Decimal | float | int,
) -> CalculationResult:
    """
    Calculate Return on Capital Employed (ROCE).
    
    Formula: EBIT / (Total Assets - Current Liabilities) × 100
    
    Args:
        ebit: Earnings Before Interest and Taxes
        total_assets: Total assets
        current_liabilities: Current liabilities
        
    Returns:
        CalculationResult with ROCE percentage
    """
    steps = []
    inputs = {}
    
    ebit_val = to_decimal(ebit)
    assets = to_decimal(total_assets)
    curr_liab = to_decimal(current_liabilities)
    
    inputs["ebit"] = float(ebit_val)
    inputs["total_assets"] = float(assets)
    inputs["current_liabilities"] = float(curr_liab)
    
    steps.append(f"EBIT = {ebit_val:,.2f}")
    steps.append(f"Total Assets = {assets:,.2f}")
    steps.append(f"Current Liabilities = {curr_liab:,.2f}")
    
    # Calculate capital employed
    capital_employed = assets - curr_liab
    steps.append(f"Capital Employed = Total Assets - Current Liabilities = {assets:,.2f} - {curr_liab:,.2f} = {capital_employed:,.2f}")
    
    if is_effectively_zero(capital_employed):
        steps.append("Capital employed is zero, cannot calculate ROCE")
        value = None
    else:
        roce = (ebit_val / capital_employed) * 100
        value = round_decimal(roce, DECIMAL_PLACES["percentage"])
        steps.append(f"ROCE = (EBIT / Capital Employed) × 100 = ({ebit_val:,.2f} / {capital_employed:,.2f}) × 100 = {value:.2f}%")
    
    return create_calculation_result(
        metric_name="Return on Capital Employed",
        value=value,
        inputs=inputs,
        calculation_steps=steps,
        category=MetricCategory.PROFITABILITY,
        custom_formula="EBIT / (Total Assets - Current Liabilities) × 100",
        custom_unit=MetricUnit.PERCENTAGE,
    )


def calculate_all_profitability_metrics(
    income_statement: IncomeStatementData,
    balance_sheet: BalanceSheetData,
    prior_balance_sheet: BalanceSheetData | None = None,
) -> MetricCollection:
    """
    Calculate all profitability metrics from financial statements.
    
    Args:
        income_statement: Current period income statement
        balance_sheet: Current period balance sheet
        prior_balance_sheet: Prior period balance sheet (for averages)
        
    Returns:
        MetricCollection with all profitability metrics
    """
    collection = MetricCollection(
        category=MetricCategory.PROFITABILITY,
        period=income_statement.period,
    )
    
    # Get prior period values for averages
    prior_assets = prior_balance_sheet.calculated_total_assets if prior_balance_sheet else None
    prior_equity = prior_balance_sheet.calculated_shareholders_equity if prior_balance_sheet else None
    
    # Gross Profit Margin
    gpm = calculate_gross_profit_margin(
        revenue=income_statement.total_revenue,
        cost_of_goods_sold=income_statement.cost_of_goods_sold,
    )
    collection.add_metric(gpm)
    
    # Operating Profit Margin
    opm = calculate_operating_profit_margin(
        revenue=income_statement.total_revenue,
        cost_of_goods_sold=income_statement.cost_of_goods_sold,
        operating_expenses=income_statement.operating_expenses,
        selling_general_admin=income_statement.selling_general_admin,
        marketing_expenses=income_statement.marketing_expenses,
        research_development=income_statement.research_development,
        depreciation_amortization=income_statement.depreciation_amortization,
        other_operating_expenses=income_statement.other_operating_expenses,
    )
    collection.add_metric(opm)
    
    # Net Profit Margin
    npm = calculate_net_profit_margin(
        revenue=income_statement.total_revenue,
        net_income=income_statement.calculated_net_income,
    )
    collection.add_metric(npm)
    
    # EBITDA Margin
    ebitda_m = calculate_ebitda_margin(
        revenue=income_statement.total_revenue,
        ebitda=income_statement.ebitda,
    )
    collection.add_metric(ebitda_m)
    
    # ROA
    roa = calculate_return_on_assets(
        net_income=income_statement.calculated_net_income,
        total_assets_begin=prior_assets or balance_sheet.calculated_total_assets,
        total_assets_end=balance_sheet.calculated_total_assets,
    )
    collection.add_metric(roa)
    
    # ROE
    roe = calculate_return_on_equity(
        net_income=income_statement.calculated_net_income,
        shareholders_equity_begin=prior_equity or balance_sheet.calculated_shareholders_equity,
        shareholders_equity_end=balance_sheet.calculated_shareholders_equity,
    )
    collection.add_metric(roe)
    
    # ROCE
    roce = calculate_return_on_capital_employed(
        ebit=income_statement.operating_income,
        total_assets=balance_sheet.calculated_total_assets,
        current_liabilities=balance_sheet.calculated_current_liabilities,
    )
    collection.add_metric(roce)
    
    return collection


class ProfitabilityCalculator(BaseCalculator):
    """Class-based profitability calculator."""
    
    def __init__(self):
        super().__init__(category=MetricCategory.PROFITABILITY)
    
    def calculate_all(
        self,
        data: FinancialStatementSet | dict[str, Any],
        prior_data: FinancialStatementSet | dict[str, Any] | None = None,
    ) -> MetricCollection:
        """Calculate all profitability metrics."""
        if isinstance(data, FinancialStatementSet):
            prior_bs = prior_data.balance_sheet if isinstance(prior_data, FinancialStatementSet) else None
            return calculate_all_profitability_metrics(
                income_statement=data.income_statement,
                balance_sheet=data.balance_sheet,
                prior_balance_sheet=prior_bs,
            )
        else:
            raise ValueError("Dictionary input not yet supported - use FinancialStatementSet")
