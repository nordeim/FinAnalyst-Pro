# finanalyst_tools/calculations/liquidity.py
"""
Liquidity ratio calculations.

Provides calculations for:
- Current Ratio
- Quick Ratio (Acid Test)
- Cash Ratio
- Working Capital
"""

from __future__ import annotations

from decimal import Decimal
from typing import Any

from finanalyst_tools.config import METRIC_FORMULAS, PlausibilityRanges
from finanalyst_tools.models.analysis_results import (
    CalculationResult,
    MetricUnit,
    MetricCategory,
    MetricCollection,
)
from finanalyst_tools.models.financial_statements import (
    BalanceSheetData,
    FinancialStatementSet,
)
from finanalyst_tools.calculations.base import (
    BaseCalculator,
    create_calculation_result,
    extract_value,
)
from finanalyst_tools.utils.math_ops import (
    to_decimal,
    safe_divide,
    round_decimal,
    is_effectively_zero,
)


# ============================================================================
# STANDALONE CALCULATION FUNCTIONS
# ============================================================================

def calculate_current_ratio(
    current_assets: Decimal | float | int,
    current_liabilities: Decimal | float | int,
) -> CalculationResult:
    """
    Calculate Current Ratio.
    
    Formula: Current Assets / Current Liabilities
    
    Interpretation:
    - < 1.0: May have difficulty meeting short-term obligations
    - 1.0 - 2.0: Generally healthy
    - > 3.0: May have excess assets not being utilized efficiently
    
    Args:
        current_assets: Total current assets
        current_liabilities: Total current liabilities
        
    Returns:
        CalculationResult with current ratio
    """
    steps = []
    warnings = []
    
    ca = to_decimal(current_assets)
    cl = to_decimal(current_liabilities)
    
    steps.append(f"Current Assets = {ca:,.2f}")
    steps.append(f"Current Liabilities = {cl:,.2f}")
    
    if is_effectively_zero(cl):
        warnings.append("Current liabilities is zero - cannot calculate ratio")
        # If no liabilities, could interpret as "infinite" liquidity
        if ca > 0:
            warnings.append("No current liabilities with positive current assets indicates strong liquidity")
        return create_calculation_result(
            metric_name="Current Ratio",
            value=None,
            formula=METRIC_FORMULAS.get("current_ratio", "Current Assets / Current Liabilities"),
            inputs={"current_assets": float(ca), "current_liabilities": float(cl)},
            steps=steps,
            category=MetricCategory.LIQUIDITY,
            warnings=warnings,
        )
    
    ratio = safe_divide(ca, cl, precision=4)
    steps.append(f"Current Ratio = Current Assets / Current Liabilities = {ca:,.2f} / {cl:,.2f} = {ratio:.4f}")
    
    # Interpretation warnings
    if ratio < Decimal("1.0"):
        warnings.append("Current ratio < 1.0 indicates potential liquidity risk")
        warnings.append("Company may have difficulty meeting short-term obligations")
    elif ratio < Decimal("1.2"):
        warnings.append("Current ratio is low - monitor liquidity position closely")
    elif ratio > Decimal("3.0"):
        warnings.append("High current ratio may indicate inefficient use of assets")
    else:
        steps.append("Current ratio is within healthy range (1.2 - 3.0)")
    
    return create_calculation_result(
        metric_name="Current Ratio",
        value=ratio,
        formula=METRIC_FORMULAS.get("current_ratio", "Current Assets / Current Liabilities"),
        inputs={"current_assets": float(ca), "current_liabilities": float(cl)},
        steps=steps,
        category=MetricCategory.LIQUIDITY,
        warnings=warnings,
    )


def calculate_quick_ratio(
    current_assets: Decimal | float | int,
    inventory: Decimal | float | int,
    current_liabilities: Decimal | float | int,
) -> CalculationResult:
    """
    Calculate Quick Ratio (Acid Test Ratio).
    
    Formula: (Current Assets - Inventory) / Current Liabilities
    
    More conservative than current ratio as inventory may not be
    quickly convertible to cash.
    
    Args:
        current_assets: Total current assets
        inventory: Inventory value
        current_liabilities: Total current liabilities
        
    Returns:
        CalculationResult with quick ratio
    """
    steps = []
    warnings = []
    
    ca = to_decimal(current_assets)
    inv = to_decimal(inventory)
    cl = to_decimal(current_liabilities)
    
    steps.append(f"Current Assets = {ca:,.2f}")
    steps.append(f"Inventory = {inv:,.2f}")
    steps.append(f"Current Liabilities = {cl:,.2f}")
    
    # Calculate quick assets
    quick_assets = ca - inv
    steps.append(f"Quick Assets = Current Assets - Inventory = {ca:,.2f} - {inv:,.2f} = {quick_assets:,.2f}")
    
    if is_effectively_zero(cl):
        warnings.append("Current liabilities is zero - cannot calculate ratio")
        return create_calculation_result(
            metric_name="Quick Ratio",
            value=None,
            formula=METRIC_FORMULAS.get("quick_ratio", "(Current Assets - Inventory) / Current Liabilities"),
            inputs={
                "current_assets": float(ca),
                "inventory": float(inv),
                "current_liabilities": float(cl),
            },
            steps=steps,
            category=MetricCategory.LIQUIDITY,
            warnings=warnings,
        )
    
    ratio = safe_divide(quick_assets, cl, precision=4)
    steps.append(f"Quick Ratio = Quick Assets / Current Liabilities = {quick_assets:,.2f} / {cl:,.2f} = {ratio:.4f}")
    
    # Interpretation
    if ratio < Decimal("1.0"):
        warnings.append("Quick ratio < 1.0 indicates reliance on inventory to meet obligations")
    elif ratio < Decimal("0.5"):
        warnings.append("Very low quick ratio - significant liquidity concern")
    
    # Compare to current ratio
    current_ratio = safe_divide(ca, cl, precision=4)
    if current_ratio > 0:
        inv_impact = current_ratio - ratio
        if inv_impact > Decimal("0.5"):
            steps.append(f"Note: Inventory accounts for {inv_impact:.2f} of the current ratio difference")
    
    return create_calculation_result(
        metric_name="Quick Ratio",
        value=ratio,
        formula=METRIC_FORMULAS.get("quick_ratio", "(Current Assets - Inventory) / Current Liabilities"),
        inputs={
            "current_assets": float(ca),
            "inventory": float(inv),
            "current_liabilities": float(cl),
            "quick_assets": float(quick_assets),
        },
        steps=steps,
        category=MetricCategory.LIQUIDITY,
        warnings=warnings,
    )


def calculate_cash_ratio(
    cash_and_equivalents: Decimal | float | int,
    current_liabilities: Decimal | float | int,
) -> CalculationResult:
    """
    Calculate Cash Ratio.
    
    Formula: Cash and Equivalents / Current Liabilities
    
    Most conservative liquidity measure - only considers cash
    and cash equivalents.
    
    Args:
        cash_and_equivalents: Cash and cash equivalents
        current_liabilities: Total current liabilities
        
    Returns:
        CalculationResult with cash ratio
    """
    steps = []
    warnings = []
    
    cash = to_decimal(cash_and_equivalents)
    cl = to_decimal(current_liabilities)
    
    steps.append(f"Cash and Equivalents = {cash:,.2f}")
    steps.append(f"Current Liabilities = {cl:,.2f}")
    
    if is_effectively_zero(cl):
        warnings.append("Current liabilities is zero - cannot calculate ratio")
        return create_calculation_result(
            metric_name="Cash Ratio",
            value=None,
            formula=METRIC_FORMULAS.get("cash_ratio", "Cash and Equivalents / Current Liabilities"),
            inputs={"cash_and_equivalents": float(cash), "current_liabilities": float(cl)},
            steps=steps,
            category=MetricCategory.LIQUIDITY,
            warnings=warnings,
        )
    
    ratio = safe_divide(cash, cl, precision=4)
    steps.append(f"Cash Ratio = Cash / Current Liabilities = {cash:,.2f} / {cl:,.2f} = {ratio:.4f}")
    
    # Interpretation
    if ratio < Decimal("0.2"):
        warnings.append("Low cash ratio - limited ability to pay obligations from cash alone")
    elif ratio > Decimal("1.0"):
        warnings.append("High cash ratio may indicate excess cash not being deployed")
        steps.append("Consider whether excess cash could be invested for better returns")
    
    return create_calculation_result(
        metric_name="Cash Ratio",
        value=ratio,
        formula=METRIC_FORMULAS.get("cash_ratio", "Cash and Equivalents / Current Liabilities"),
        inputs={"cash_and_equivalents": float(cash), "current_liabilities": float(cl)},
        steps=steps,
        category=MetricCategory.LIQUIDITY,
        warnings=warnings,
    )


def calculate_working_capital(
    current_assets: Decimal | float | int,
    current_liabilities: Decimal | float | int,
    currency: str = "SGD",
) -> CalculationResult:
    """
    Calculate Working Capital.
    
    Formula: Current Assets - Current Liabilities
    
    This is an absolute amount, not a ratio.
    
    Args:
        current_assets: Total current assets
        current_liabilities: Total current liabilities
        currency: Currency code for the result
        
    Returns:
        CalculationResult with working capital amount
    """
    steps = []
    warnings = []
    
    ca = to_decimal(current_assets)
    cl = to_decimal(current_liabilities)
    
    steps.append(f"Current Assets = {ca:,.2f}")
    steps.append(f"Current Liabilities = {cl:,.2f}")
    
    working_capital = ca - cl
    steps.append(f"Working Capital = Current Assets - Current Liabilities = {ca:,.2f} - {cl:,.2f} = {working_capital:,.2f}")
    
    # Interpretation
    if working_capital < 0:
        warnings.append("Negative working capital indicates current liabilities exceed current assets")
        warnings.append("This may indicate liquidity problems or aggressive working capital management")
    elif working_capital == 0:
        warnings.append("Zero working capital - current assets exactly match current liabilities")
    
    result = create_calculation_result(
        metric_name="Working Capital",
        value=round_decimal(working_capital, 2),
        formula=METRIC_FORMULAS.get("working_capital", "Current Assets - Current Liabilities"),
        inputs={"current_assets": float(ca), "current_liabilities": float(cl)},
        steps=steps,
        category=MetricCategory.LIQUIDITY,
        warnings=warnings,
    )
    
    # Override unit to currency
    result.unit = MetricUnit.CURRENCY
    
    return result


def calculate_all_liquidity_metrics(
    balance_sheet: BalanceSheetData,
) -> MetricCollection:
    """
    Calculate all liquidity metrics.
    
    Args:
        balance_sheet: Balance sheet data
        
    Returns:
        MetricCollection with all liquidity metrics
    """
    collection = MetricCollection(
        category=MetricCategory.LIQUIDITY,
        period=balance_sheet.period,
    )
    
    # Current Ratio
    current = calculate_current_ratio(
        current_assets=balance_sheet.calculated_current_assets,
        current_liabilities=balance_sheet.calculated_current_liabilities,
    )
    collection.add_metric(current)
    
    # Quick Ratio
    quick = calculate_quick_ratio(
        current_assets=balance_sheet.calculated_current_assets,
        inventory=balance_sheet.inventory,
        current_liabilities=balance_sheet.calculated_current_liabilities,
    )
    collection.add_metric(quick)
    
    # Cash Ratio
    cash = calculate_cash_ratio(
        cash_and_equivalents=balance_sheet.cash_and_equivalents,
        current_liabilities=balance_sheet.calculated_current_liabilities,
    )
    collection.add_metric(cash)
    
    # Working Capital
    wc = calculate_working_capital(
        current_assets=balance_sheet.calculated_current_assets,
        current_liabilities=balance_sheet.calculated_current_liabilities,
        currency=balance_sheet.currency,
    )
    collection.add_metric(wc)
    
    return collection


class LiquidityCalculator(BaseCalculator):
    """Class-based calculator for liquidity metrics."""
    
    def __init__(self):
        super().__init__(MetricCategory.LIQUIDITY)
    
    def calculate_all(
        self,
        statement_set: FinancialStatementSet,
        prior_statement_set: FinancialStatementSet | None = None,
    ) -> MetricCollection:
        """Calculate all liquidity metrics."""
        return calculate_all_liquidity_metrics(statement_set.balance_sheet)
