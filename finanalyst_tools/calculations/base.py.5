# finanalyst_tools/calculations/base.py
"""
Base classes and utilities for financial calculations.

Provides:
- BaseCalculator abstract class for consistent calculation patterns
- Factory function for creating CalculationResult objects
- Helper functions for extracting values from financial statements
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Any, Callable

from finanalyst_tools.config import (
    DECIMAL_PLACES,
    PlausibilityRanges,
    METRIC_FORMULAS,
    METRIC_UNITS,
)
from finanalyst_tools.models.analysis_results import (
    CalculationResult,
    MetricUnit,
    MetricCategory,
    MetricCollection,
)
from finanalyst_tools.models.financial_statements import (
    IncomeStatementData,
    BalanceSheetData,
    CashFlowStatementData,
    FinancialStatementSet,
)
from finanalyst_tools.utils.math_ops import (
    to_decimal,
    safe_divide,
    round_decimal,
    calculate_percentage,
    calculate_average,
)


def get_metric_unit(metric_name: str) -> MetricUnit:
    """
    Get the appropriate unit for a metric.
    
    Args:
        metric_name: Name of the metric
        
    Returns:
        MetricUnit enum value
    """
    unit_str = METRIC_UNITS.get(metric_name.lower(), "ratio")
    unit_map = {
        "percentage": MetricUnit.PERCENTAGE,
        "ratio": MetricUnit.RATIO,
        "currency": MetricUnit.CURRENCY,
        "days": MetricUnit.DAYS,
        "count": MetricUnit.COUNT,
        "times": MetricUnit.TIMES,
    }
    return unit_map.get(unit_str, MetricUnit.RATIO)


def get_metric_formula(metric_name: str) -> str:
    """
    Get the formula for a metric.
    
    Args:
        metric_name: Name of the metric
        
    Returns:
        Formula string
    """
    return METRIC_FORMULAS.get(metric_name.lower(), "N/A")


def create_calculation_result(
    metric_name: str,
    value: Decimal | None,
    formula: str,
    inputs: dict[str, Any],
    steps: list[str],
    category: MetricCategory | None = None,
    warnings: list[str] | None = None,
) -> CalculationResult:
    """
    Factory function to create a CalculationResult with plausibility check.
    
    Args:
        metric_name: Name of the metric
        value: Calculated value (or None if calculation failed)
        formula: Formula used for calculation
        inputs: Dictionary of input values used
        steps: List of calculation steps for audit trail
        category: Metric category
        warnings: List of warning messages
        
    Returns:
        Complete CalculationResult with plausibility assessment
    """
    # Get plausibility range
    plausibility_range = PlausibilityRanges.get_range(metric_name)
    
    # Check plausibility
    is_plausible = True
    if value is not None and plausibility_range is not None:
        float_value = float(value)
        is_plausible = plausibility_range[0] <= float_value <= plausibility_range[1]
    
    # Get unit
    unit = get_metric_unit(metric_name)
    
    # Build result
    result = CalculationResult(
        metric_name=metric_name,
        value=value,
        unit=unit,
        formula=formula,
        inputs=inputs,
        calculation_steps=steps,
        is_plausible=is_plausible,
        plausibility_range=plausibility_range,
        warnings=warnings or [],
        category=category,
    )
    
    # Add plausibility warning if needed
    if not is_plausible and plausibility_range:
        result.add_warning(
            f"Value {float(value):.2f} is outside typical range "
            f"({plausibility_range[0]:.1f} to {plausibility_range[1]:.1f})"
        )
    
    return result


def extract_value(
    data: dict[str, Any] | IncomeStatementData | BalanceSheetData | CashFlowStatementData,
    field_name: str,
    default: Decimal | None = None,
) -> Decimal:
    """
    Extract a value from financial data, handling both dict and model inputs.
    
    Args:
        data: Financial data (dict or Pydantic model)
        field_name: Name of the field to extract
        default: Default value if field not found
        
    Returns:
        Decimal value
    """
    if default is None:
        default = Decimal("0")
    
    # Convert model to dict if needed
    if hasattr(data, "model_dump"):
        data_dict = data.model_dump(by_alias=False)
    elif hasattr(data, "__dict__"):
        data_dict = data.__dict__
    else:
        data_dict = data
    
    # Try to get the value
    value = data_dict.get(field_name)
    
    if value is None:
        return default
    
    return to_decimal(value, default=default)


class BaseCalculator(ABC):
    """
    Abstract base class for financial calculators.
    
    Provides common functionality:
    - Consistent result creation
    - Step logging
    - Plausibility checking
    - Warning accumulation
    """
    
    def __init__(self, category: MetricCategory):
        """
        Initialize the calculator.
        
        Args:
            category: The category of metrics this calculator produces
        """
        self.category = category
        self._current_steps: list[str] = []
        self._current_warnings: list[str] = []
        self._current_inputs: dict[str, Any] = {}
    
    def _reset(self) -> None:
        """Reset calculation state for a new calculation."""
        self._current_steps = []
        self._current_warnings = []
        self._current_inputs = {}
    
    def _add_step(self, step: str) -> None:
        """Add a calculation step."""
        step_num = len(self._current_steps) + 1
        self._current_steps.append(f"Step {step_num}: {step}")
    
    def _add_warning(self, warning: str) -> None:
        """Add a warning message."""
        self._current_warnings.append(warning)
    
    def _record_input(self, name: str, value: Any) -> None:
        """Record an input value."""
        if isinstance(value, Decimal):
            self._current_inputs[name] = float(value)
        else:
            self._current_inputs[name] = value
    
    def _create_result(
        self,
        metric_name: str,
        value: Decimal | None,
        formula: str,
    ) -> CalculationResult:
        """Create a calculation result with current state."""
        return create_calculation_result(
            metric_name=metric_name,
            value=value,
            formula=formula,
            inputs=self._current_inputs.copy(),
            steps=self._current_steps.copy(),
            category=self.category,
            warnings=self._current_warnings.copy(),
        )
    
    @abstractmethod
    def calculate_all(
        self,
        statement_set: FinancialStatementSet,
        prior_statement_set: FinancialStatementSet | None = None,
    ) -> MetricCollection:
        """
        Calculate all metrics for this category.
        
        Args:
            statement_set: Current period financial statements
            prior_statement_set: Prior period statements (for averages)
            
        Returns:
            MetricCollection with all calculated metrics
        """
        pass
